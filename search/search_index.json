{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to My Open RAN and 5G Documentation","text":"<p>Hi! I'm Ali, a telecom engineer with a BSc from Amirkabir University of Technology. Passionate about 5G, cloud computing, DevOps, and Linux. This page is where I document my learnings about 5G RAN, programming languages, and DevOps tools that I explore in my free time.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Welcome to My Open RAN and 5G Documentation</li> <li>Table of Contents</li> <li>About Me</li> <li>What is Open RAN?</li> <li>5G RAN Overview</li> <li>Programming Languages I Use</li> <li>DevOps Tools I'm Learning</li> <li>Resources</li> <li>How to Contribute</li> </ul>"},{"location":"#about-me","title":"About Me","text":"<p>I'm passionate about telecommunications and open-source technologies. My work focuses on Open RAN and 5G RAN, and I enjoy exploring how programming and DevOps can improve network automation and efficiency.</p>"},{"location":"#what-is-open-ran","title":"What is Open RAN?","text":"<p>Open RAN (Open Radio Access Network) is a concept that promotes interoperability and openness in the RAN ecosystem. It allows network operators to mix and match components from different vendors, reducing costs and increasing flexibility.</p> <p>Key Benefits: - Interoperability: Use hardware and software from multiple vendors. - Cost Efficiency: Reduce dependency on proprietary solutions. - Innovation: Foster a competitive ecosystem. - Intelegency: Define an inteligent controller in the RAN.</p>"},{"location":"#5g-ran-overview","title":"5G RAN Overview","text":"<p>5G RAN (Radio Access Network) is the backbone of 5G networks, enabling high-speed, low-latency communication. It consists of: - gNodeB: The base station in 5G networks. - Massive MIMO: Technology for improving capacity and coverage. - Network Slicing: Allows multiple virtual networks on a single physical infrastructure.</p>"},{"location":"#programming-languages-i-use","title":"Programming Languages I Use","text":"<p>Here are some programming languages I use or am learning: - Python: For automation and data analysis. - C/C++: For using open-source softwarized 5G elements (e.g. OpenAireInterface5G). - Bash: For scripting and automation in Linux environments.</p>"},{"location":"#devops-tools-im-learning","title":"DevOps Tools I'm Learning","text":"<p>I'm exploring the following DevOps tools to improve network automation and deployment: - Ansible: For configuration management and automation. - Docker: For containerization. - Kubernetes: For container orchestration.</p>"},{"location":"#resources","title":"Resources","text":"<p>Here are some resources I find helpful: - O-RAN Alliance - 5G PPP - DevOps Roadmap - Markdown Guide</p>"},{"location":"#how-to-contribute","title":"How to Contribute","text":"<p>If you'd like to contribute or suggest improvements, feel free to: 1. Fork this repository. 2. Submit a pull request with your changes.</p> <p>Thank you for visiting! Let's build a more open and innovative future together.</p>"},{"location":"C-CPP/","title":"C/CPP Training","text":"<p>This page will contain C/CPP trainings. There are many problems to solve. let's go!  </p>"},{"location":"C-CPP/#basic","title":"Basic","text":"<p>In C or any other programming language, there are basic definitions for input/output, variables, mathematical operations, flow control and loops. This is a simple C program that simulates a network packet counter, a tool you might find in Linux or telecommunications systems to track data packets. It demonstrates fundamental C programming concepts\u2014primitive variables, input/output, control flow, and loops\u2014all working together in a practical example.  </p>"},{"location":"C-CPP/#code-network-packet-counter-simulator","title":"Code: Network Packet Counter Simulator","text":"<p>The code for network packet counter simulator: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n\nint main(){\n    int cycles;\n    int pkt_per_cycle;\n    int lost_pkt;\n    float pkt_loss;\n    // Seed random number generator\n    srand(time(NULL));\n\n    while (1){\n        printf(\"Enter number of cycles (1-10) to process (0 to quit): \");\n        scanf(\"%d\", &amp;cycles);\n        if (cycles == 0){\n            printf(\"Good Bye!\\n\");\n            break;\n        }\n        else if (cycles &lt; 1 || cycles &gt; 10){\n            printf(\"Invalid number of cycles. Please enter a number between 1 and 10.\\n\");\n            continue;\n        }\n        else{\n            int pkt_counter = 0;\n            int pkt_processed = 0;\n            for (int i = 0; i &lt; cycles; i++){\n                pkt_per_cycle = rand() % 20 + 1; // 1 to 20\n                // Ensure denominator for rand() % n is at least 1\n                int max_lost = (pkt_per_cycle / 2) &gt; 0 ? pkt_per_cycle / 2 : 1;\n                lost_pkt = rand() % max_lost; // Max loss is half, min 1\n                pkt_counter += pkt_per_cycle;\n                pkt_processed += pkt_per_cycle - lost_pkt;\n                pkt_loss = (float)lost_pkt / pkt_per_cycle * 100;\n                printf(\"Cycle %d: %d packets generated, %d packets lost (%.2f%% loss)\\n\", i + 1, pkt_per_cycle, lost_pkt, pkt_loss);\n            }\n            float avg_loss = (float)(pkt_counter - pkt_processed) / pkt_counter * 100;\n            printf(\"Total packets generated: %d\\n\", pkt_counter);\n            printf(\"Total packets processed: %d\\n\", pkt_processed);\n            printf(\"Average packet loss: %.2f%%\\n\", avg_loss);\n        }\n    }\n    return 0;\n}\n</code></pre></p> <p>to compile this code, simply use: <pre><code> gcc pkt_counter.c -o pkt_counter\n</code></pre> The expected output is: <pre><code>./pkt_counter \nEnter number of cycles (1-10) to process (0 to quit): 18\nInvalid number of cycles. Please enter a number between 1 and 10.\nEnter number of cycles (1-10) to process (0 to quit): 6\nCycle 1: 15 packets generated, 6 packets lost (40.00% loss)\nCycle 2: 16 packets generated, 5 packets lost (31.25% loss)\nCycle 3: 9 packets generated, 2 packets lost (22.22% loss)\nCycle 4: 13 packets generated, 0 packets lost (0.00% loss)\nCycle 5: 15 packets generated, 1 packets lost (6.67% loss)\nCycle 6: 10 packets generated, 1 packets lost (10.00% loss)\nTotal packets generated: 78\nTotal packets processed: 63\nAverage packet loss: 19.23%\nEnter number of cycles (1-10) to process (0 to quit): 0\nGood Bye!\n</code></pre></p>"},{"location":"C-CPP/#arrays","title":"Arrays","text":"<p>Working with several separated element isn't so practical. So we utilize arrays. An array is a bunch of ordered elements with same type. It starts with 0 index. Here is an example.</p>"},{"location":"C-CPP/#code-bubble-sort","title":"Code: Bubble-Sort","text":"<p>Bubbble sort is a method to sort elements. At each iteration, it fixes the biggest existed number. Time complexity of this algorithm is O(n^2^). <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    int arr[] = {7,2,3,8,6,9,12};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int temp;\n    for (int i=0; i&lt;n; i++)\n        for(int j=0; j&lt;n-i; j++)\n            if (arr[j] &gt; arr[j+1])\n            {\n                temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n    for (int i=0; i&lt;n; i++)\n        printf(\"%d\\n\", arr[i]);\n}\n</code></pre></p>"},{"location":"C-CPP/#code-one-line-for-loop","title":"Code: One-Line <code>for</code> Loop","text":"<p>In this short code, we want to count number of array elemnts smaller than <code>4</code>. <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    int counter = 0;\n    int arr[] = {1,2,3,4,5,6,7,8,9};\n    for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); i++)\n        counter = arr[i] &lt; 4 ? ++counter : counter;\n    printf(\"Number of elements less than 4: %d\\n\", counter);\n    return 0;\n}\n</code></pre></p> <p>It could be rewrite as a is shortened code. <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    int counter = 0;\n    int arr[] = {1,2,3,4,5,6,7,8,9};\n    for (int i = 0; i &lt; sizeof(arr)/sizeof(arr[0]); counter += arr[i++] &lt; 4){}\n    printf(\"Number of elements less than 4: %d\\n\", counter);\n    return 0;\n}\n</code></pre></p>"},{"location":"C-CPP/#functions","title":"Functions","text":"<p>Functions are functions! they take some parameters(arguments) and give the value. Functions are defined and are called; If a function is defined after <code>main()</code> it should be declared before the it. Functions help to code in a structured manner. <pre><code>#include &lt;stdio.h&gt;\n\n// Function Declaration\nvoid myFunction(int a, int b)\n\n// main\nint main()\n{\n    /* some\n    code here\n    */\n\n    //Function Call\n    myFunction()\n\n}\n\n//Function definition\nvoid myFunction(int a, int b)\n{\n    /* some\n    code here\n    */\n}\n</code></pre> Functions don't have to be called inside main, they can call each other and even the can be called by themselves. These functions are Recursive Functions.  </p>"},{"location":"C-CPP/#code-hanoi-tower","title":"Code: Hanoi Tower","text":"<p>In this code we can define a recursive function to solve the tower of hanoi Problem. The time complexity of this solution is O(2^n^). Tower of Hanoi is a mathematical puzzle where we have three towers and <code>n</code> disks. The objective of the puzzle is to move the entire stack to another tower, obeying the following simple rules: 1) Only one disk can be moved at a time. 2) Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack. 3) No disk may be placed on top of a smaller disk. <pre><code>#include &lt;stdio.h&gt;\n\nvoid hanoiTower (int n, char src, char helping, char dst);\n\nint main ()\n{\n    int n = 8;\n    char src='S'; char dst='D'; char helping='H';\n    hanoiTower(n, src, helping, dst);\n    return 0;\n\n}\n\nvoid hanoiTower (int n, char src, char helping, char dst)\n{\n    if (n==1)\n        printf(\"Disk %d: %c -&gt; %c\\n\", n, src, dst);\n    else\n    {\n        hanoiTower(n-1, src, dst, helping);\n        printf(\"Disk %d: %c -&gt; %c\\n\", n, src, dst);\n        hanoiTower(n-1, helping, src, dst);\n    }\n\n}\n</code></pre></p>"},{"location":"C-CPP/#pointers","title":"Pointers","text":"<p>Pointers are one of the most fundamental and powerful features in C. They allow direct memory access and manipulation, making them essential for efficient programming. This review covers key pointer concepts with sample code.  </p>"},{"location":"C-CPP/#code-pointer-to-pointer","title":"Code: Pointer to Pointer","text":"<p>A pointer to a pointer is a variable that stores the address of another pointer. This is useful for modifying pointers inside functions. <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10;\n    int *ptr = &amp;a;\n    int **ptr2 = &amp;ptr;\n\n    printf(\"Value of a: %d\\n\", a);\n    printf(\"Value using ptr: %d\\n\", *ptr);\n    printf(\"Value using ptr2: %d\\n\", **ptr2);\n    printf(\"Address of a: %p\\n\", &amp;a);\n    printf(\"Address of ptr: %p\\n\", ptr);\n    printf(\"Address of ptr2: %p\\n\", ptr2);\n\n\n    return 0;\n}\n</code></pre> Result: <pre><code>Value of a: 10\nValue using ptr: 10\nValue using ptr2: 10\nAddress of a: 0x7ffca7bd9e24\nAddress of ptr: 0x7ffca7bd9e24\nAddress of ptr2: 0x7ffca7bd9e28\n</code></pre></p>"},{"location":"C-CPP/#code-dynamic-memory-allocation","title":"Code: Dynamic Memory Allocation","text":"<p>Dynamic memory allocation allows allocating memory at runtime using malloc, calloc, realloc, and freeing it with free. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    int *arr;\n    int n;\n    printf(\"Enter number of elements: \");\n    scanf(\"%d\", &amp;n);\n    arr = (int *)malloc(n * sizeof(int)); // Allocate memory\n    if (arr == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    for (int i = 0; i &lt; n; i++) {\n        arr[i] = i * 10;\n        printf(\"%d\\n\", arr[i]);\n    }\n\n    free(arr); // Free allocated memory\n    return 0;\n}\n</code></pre></p>"},{"location":"C-CPP/#code-call-by-reference-returning-multiple-parameters","title":"Code: Call by Reference (Returning Multiple Parameters)","text":"<p>Using pointers, we can return multiple values from a function. <pre><code>#include &lt;stdio.h&gt;\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nint main() {\n    int x = 5, y = 10;\n    swap(&amp;x, &amp;y);\n    printf(\"After swapping: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n</code></pre> Result: <pre><code>After swapping: x = 10, y = 5\n</code></pre></p>"},{"location":"C-CPP/#code-function-pointer-selecting-a-mathematical-operation","title":"Code: Function Pointer (Selecting a Mathematical Operation)","text":"<p>Function pointers allow us to select and execute different functions dynamically. Here, we demonstrate their use in selecting a mathematical operation at runtime. <pre><code>#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\nint subtract(int a, int b) { return a - b; }\nint multiply(int a, int b) { return a * b; }\n\nint main() {\n    int (*operation)(int, int); // Function pointer\n    int choice, a = 10, b = 5;\n\n    printf(\"Select operation: 1. Add 2. Subtract 3. Multiply\\n\");\n    scanf(\"%d\", &amp;choice);\n\n    switch (choice) {\n        case 1: operation = add; break;\n        case 2: operation = subtract; break;\n        case 3: operation = multiply; break;\n        default: printf(\"Invalid choice\\n\"); return 1;\n    }\n\n    printf(\"Result: %d\\n\", operation(a, b));\n    return 0;\n}\n</code></pre> Result: <pre><code>./function_pointer \nSelect operation: 1. Add 2. Subtract 3. Multiply\n1\nResult: 15\n./function_pointer \nSelect operation: 1. Add 2. Subtract 3. Multiply\n2\nResult: 5\n./function_pointer \nSelect operation: 1. Add 2. Subtract 3. Multiply\n3\nResult: 50\n</code></pre></p>"},{"location":"C-CPP/#code-callback-function-arbitrary-bubble-sort","title":"Code: Callback Function (Arbitrary Bubble Sort)","text":"<p>Function pointers enable callbacks, allowing flexible behavior. Here, we use a callback function for sorting. <pre><code>#include &lt;stdio.h&gt;\n\nvoid bubbleSort(int arr[], int n, int (*compare)(int, int)) {\n    for (int i=0; i&lt;n-1; i++) {\n        for (int j=0; j&lt;n-i-1; j++) {\n            if (compare(arr[j], arr[j+1])) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nint ascending(int a, int b) { return a &gt; b; }\nint descending(int a, int b) { return a &lt; b; }\n\nint main() {\n    int arr[] = {7,2,3,8,6,9,12};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    bubbleSort(arr, n, ascending);\n    printf(\"Sorted in ascending order: \");\n    for (int i=0; i&lt;n; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n\n    bubbleSort(arr, n, descending);\n    printf(\"Sorted in descending order: \");\n    for (int i=0; i&lt;n; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre> Result: <pre><code>Sorted in ascending order: 2 3 6 7 8 9 12 \nSorted in descending order: 12 9 8 7 6 3 2 \n</code></pre></p>"},{"location":"C-CPP/#code-lvalue-and-rvalue","title":"Code: Lvalue and Rvalue","text":"<p>In C/C++, an Lvalue (left value) is an object that persists beyond a single expression, meaning it has an identifiable memory location. An Rvalue (right value) is a temporary value that does not have a permanent memory address. A function returning a reference allows modification of its return value, as seen in the following example: <pre><code>#include &lt;stdio.h&gt;\n\nint&amp; min (int&amp; x, int&amp; y) {\n    return (x &lt; y) ? x : y;\n}\n\nint main() {\n    int x = 3, y = 2;\n    min(x, y) = 6; // Modifies the smaller value directly\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n</code></pre> It could be compile using <code>g++</code>. Explain: - <code>min(x, y)</code> returns a reference to either <code>x</code> or <code>y</code>. - Assigning <code>6</code> to <code>min(x, y)</code> modifies the referenced variable. - If <code>y</code> is smaller, <code>y</code> becomes <code>6</code>, otherwise <code>x</code> does. Result: <pre><code>x = 3, y = 6\n</code></pre></p>"},{"location":"C-CPP/#file-handling-and-string-manipulation-in-c","title":"File Handling and String Manipulation in C","text":"<p>File handling in C allows programs to interact with files on the system for reading, writing, or modifying data. This is achieved using standard library functions like <code>fopen</code>, <code>fclose</code>, <code>fread</code>, <code>fwrite</code>, <code>fprintf</code>, and <code>fscanf</code>. These functions enable operations such as opening a file in different modes (e.g., read, write, append), reading data line by line or in chunks, and writing formatted or raw data to files. Strings in C are represented as arrays of characters terminated by a null character (<code>'\\0'</code>). Common string manipulation functions include <code>strlen</code>, <code>strcpy</code>, <code>strcat</code>, and <code>strcmp</code>, which allow developers to calculate string length, copy strings, concatenate them, or compare them. Combining file handling and string manipulation is essential for tasks like parsing text files, searching for specific patterns, or processing logs.  </p>"},{"location":"C-CPP/#code-grep-like-app","title":"Code: grep-like app","text":"<p>Below is an example of a simple <code>grep-like</code> application in C. This program reads a file line by line via <code>fgets()</code>and prints lines containing a specified search string using <code>strstr</code>.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_LINE_LENGTH 1024\n\nint main (int argc, char *argv[])\n{\n    if (argc != 3)\n    {\n        printf (\"Usage: %s &lt;filename&gt; &lt;search_string&gt;. \\n\", argv[0]);\n        return 1;\n    }\n\n    const char *filename = argv[1];\n    const char *search_string = argv[2];\n\n    FILE *file = fopen(filename, \"r\");\n\n    if (!file)\n    {\n        perror(\"cannot open the file\");\n        return 1;\n    }\n\n    char line[MAX_LINE_LENGTH];\n    int line_number = 0;\n\n    while (fgets(line, sizeof(line), file))\n    {\n        line_number++;\n        // Remove newline character if present -- It is related to printf() function to prevent printing empty line\n        line[strcspn(line, \"\\n\")] = '\\0';\n\n        // Check if the line contains the search string\n        if (strstr(line, search_string)) {\n            printf(\"Line %d: %s\\n\", line_number, line);\n        }\n    }\n\n    fclose(file);\n    return 0;\n}\n</code></pre>"},{"location":"C-CPP/#structs-and-enums","title":"Structs and Enums","text":"<p>Structs are user-defined types in C. They are a combination of several types. Each attribute can be accessible through <code>.</code> or <code>-&gt;</code>, if the struct is defined derectly or using pointers, respectively. On the other hand, <code>enums</code> in C are user-defined types that assigns names to a set of integral values, making code more readable. The <code>typedef</code> is a keyword that is used to provide existing data types with a new name. The C <code>typedef</code> keyword is used to redefine the name of already existing data types including <code>enums</code> and <code>struct</code>. There are some other topics like bit fields and unions that won't be mentioned here!</p>"},{"location":"C-CPP/#code-network-status-report","title":"Code: Network Status Report","text":"<p>Here is a simple program that stores network status using <code>structs</code> and <code>enums</code>. <pre><code>#include &lt;stdio.h&gt;\n\ntypedef enum {\n    DISCONNECTED,\n    CONNECTING,\n    CONNECTED,\n    ERROR\n} NetworkStatus;\n\ntypedef struct {\n    char name[20];\n    int id;\n    NetworkStatus status;  // Use the NetworkStatus enum\n} NetworkDevice;\n\nint main() {\n    NetworkDevice device = {\"Router_1\", 101, CONNECTED};\n\n    // Print device details\n    printf(\"Device Name: %s\\n\", device.name);\n    printf(\"Device ID: %d\\n\", device.id);\n    printf(\"Network Status: \");\n\n    // Use a switch to display the status as text\n    switch (device.status) {\n        case DISCONNECTED:\n            printf(\"Disconnected\\n\");\n            break;\n        case CONNECTING:\n            printf(\"Connecting...\\n\");\n            break;\n        case CONNECTED:\n            printf(\"Connected\\n\");\n            break;\n        case ERROR:\n            printf(\"Error\\n\");\n            break;\n        default:\n            printf(\"Unknown status\\n\");\n    }\n\n    return 0;\n}\n</code></pre></p>"},{"location":"C-CPP/#object-oriented-programming-oop-in-c-detailed-lecture-documentation-with-code","title":"Object-Oriented Programming (OOP) in C++ - Detailed Lecture Documentation with Code","text":"<p>This part of document provides a comprehensive and detailed breakdown of the OOP concepts and C++ code examples presented in the video.This video provides a great tutorial for exploring OOP. This section is based on the lecturer's points (thanks to the gemini), with some additional insights I have included.</p>"},{"location":"C-CPP/#introduction-to-oop","title":"Introduction to OOP","text":"<p>The concept of Object-Oriented Programming (OOP) is a programming paradigm. OOP is a methodology for organizing code based on objects and serves as a way to model real-world entities in code. The document emphasizes OOP's focus on rules, ideas, and concepts for problem-solving, with an emphasis on representing real-life objects, their attributes, and behaviors. To illustrate this, We use the example of a \"car\" object. A car has attributes like manufacturer, color, and model, and behaviors like driving, accelerating, and braking. </p>"},{"location":"C-CPP/#classes-and-objects","title":"Classes and Objects","text":"<p>Now we discusse classes and objects. A class is a user-defined data type that serves as a blueprint for creating objects. It groups related data (attributes) and functions (methods). Tt is fair to compare classes with predefined data types (int, string, etc.), noting that classes are more complex and can hold multiple variables. Let's create an <code>Employee</code> class:</p> <pre><code>    class Employee {\n    public:\n        std::string Name;\n        std::string Company;\n        int Age;\n    };\n</code></pre> <p>This class defines the structure for <code>employee</code> objects, with attributes for <code>name</code>, <code>company</code>, and <code>age</code>. We can create objects (instances) of the <code>Employee</code> class and how to assign values to the object's attributes:</p> <pre><code>    Employee employee1;\n    employee1.Name = \"John Doe\";\n    employee1.Company = \"ABC Corp\";\n    employee1.Age = 30;\n\n    Employee employee2;\n    employee2.Name = \"Jane Smith\";\n    employee2.Company = \"XYZ Inc\";\n    employee2.Age = 25;\n</code></pre> <p>Here, <code>employee1</code> and <code>employee2</code> are objects of the <code>Employee</code> class.</p>"},{"location":"C-CPP/#access-modifiers","title":"Access Modifiers","text":"<p>Attributes of a class can be in different levels of accessibility.  Access modifiers types in C++.     * <code>private</code>, <code>public</code>, and <code>protected</code>.     * Control the visibility and accessibility of class members.  Explanation of the <code>private</code> access modifier.     * Members are only accessible within the class.     * Used for data hiding. * Explanation of the <code>public</code> access modifier.     * Members are accessible from outside the class.     * Protected is briefly mentioned as a topic for later.     * The code from the previous section demonstrates the use of the <code>public</code> access modifier.  </p> <p>The code from the previous section demonstrates the use of the <code>public</code> access modifier, as the attributes <code>Name</code>, <code>Company</code>, and <code>Age</code> are declared as public.</p>"},{"location":"C-CPP/#class-methods","title":"Class Methods","text":"<p>Class methods are functions within a class that define the behaviors of objects. The following C++ code is provided for creating an <code>introduceYourself()</code> method for the <code>Employee</code> class:  </p> <pre><code>    class Employee {\n    public:\n        std::string Name;\n        std::string Company;\n        int Age;\n\n        void introduceYourself() {\n            std::cout &lt;&lt; \"Name: \" &lt;&lt; Name &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Company: \" &lt;&lt; Company &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Age: \" &lt;&lt; Age &lt;&lt; std::endl;\n        }\n    };\n\n    //Calling the method.\n    employee1.introduceYourself();\n</code></pre> <p>This method allows an <code>Employee</code> object to print its name, company, and age.</p>"},{"location":"C-CPP/#constructors","title":"Constructors","text":"<p>Constructors are special methods automatically called when an object is created and are used to initialize object attributes. It outlines the rules for creating constructors, including having no return type, the same name as the class, and usually being <code>public</code>. The following C++ code that modifies the \"Employee\" class is provided to include a constructor:</p> <p><pre><code>    class Employee {\n    public:\n        std::string Name;\n        std::string Company;\n        int Age;\n\n        Employee(std::string name, std::string company, int age) : Name(name), Company(company), Age(age) {}\n\n        void introduceYourself() {\n            std::cout &lt;&lt; \"Name: \" &lt;&lt; Name &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Company: \" &lt;&lt; Company &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Age: \" &lt;&lt; Age &lt;&lt; std::endl;\n        }\n    };\n\n    Employee employee1(\"John Doe\", \"ABC Corp\", 30); // Using the constructor\n    employee1.introduceYourself();\n</code></pre> This constructor initializes the <code>Name</code>, <code>Company</code>, and <code>Age</code> attributes when an <code>Employee</code> object is created.</p>"},{"location":"C-CPP/#oop-principles","title":"OOP Principles","text":"<p>There are four pillars for OOP: Encapsulation, Abstraction, Inheritance, and Polymorphism.</p>"},{"location":"C-CPP/#encapsulation","title":"Encapsulation","text":"<p>Encapsulation involves bundling data and methods within a class and restricting direct access to data. You can add any attribute to your class and set proper access control policy for each one. There are 3 types of access modifier as depicted in figure below. Encapsulation in C++ [Credit: https://logicmojo.com/encapsulation-in-cpp] The following C++ code implements encapsulation in the \"Employee\" class:</p> <p><pre><code>    class Employee {\n    private:\n        std::string Name;\n        std::string Company;\n        int Age;\n\n    public:\n        Employee(std::string name, std::string company, int age) : Name(name), Company(company), Age(age) {}\n\n        std::string getName() const { return Name; }\n        void setName(const std::string&amp; name) { Name = name; }\n\n        std::string getCompany() const { return Company; }\n        void setCompany(const std::string&amp; company) { Company = company; }\n\n        int getAge() const { return Age; }\n        void setAge(int age) { Age = age; }\n\n        void introduceYourself() {\n            std::cout &lt;&lt; \"Name: \" &lt;&lt; Name &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Company: \" &lt;&lt; Company &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Age: \" &lt;&lt; Age &lt;&lt; std::endl;\n        }\n    };\n</code></pre> In this encapsulated version, <code>Name</code>, <code>Company</code>, and <code>Age</code> are made private, and public getter and setter methods are provided to control access to them.</p>"},{"location":"C-CPP/#abstraction","title":"Abstraction","text":"<p>Abstraction involves hiding complex implementation details and presenting a simplified interface. Data abstraction in C++ [Credit: https://www.softwaretestinghelp.com/data-abstraction-in-cpp/] Note that abstract classes cannot be instantiated and pure virtual functions are declared with <code>= 0</code>. The following C++ code creates an abstract <code>AbstractEmployee</code> class with a simple interface:</p> <pre><code>    class AbstractEmployee {\n    public:\n        virtual void askForPromotion() = 0; // Pure virtual function\n    };\n\n    class Employee : public AbstractEmployee {\n    private:\n        std::string Name;\n        std::string Company;\n        int Age;\n\n    public:\n        Employee(std::string name, std::string company, int age)\n            : Name(name), Company(company), Age(age) {}\n\n        std::string getName() const { return Name; }\n        void setName(const std::string&amp; name) { Name = name; }\n        std::string getCompany() const { return Company; }\n        void setCompany(const std::string&amp; company) { Company = company; }\n        int getAge() const { return Age; }\n        void setAge(int age) { Age = age; }\n\n        void introduceYourself()  {\n            std::cout &lt;&lt; \"Name: \" &lt;&lt; Name &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Company: \" &lt;&lt; Company &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Age: \" &lt;&lt; Age &lt;&lt; std::endl;\n        }\n        void askForPromotion()  {\n             if (Age &gt; 30)\n                std::cout &lt;&lt; Name &lt;&lt; \" got promoted!\" &lt;&lt; std::endl;\n            else\n                std::cout &lt;&lt; Name &lt;&lt; \" no promotion for you!\" &lt;&lt; std::endl;\n        }\n    };\n</code></pre> <p>Here, <code>AbstractEmployee</code> is an abstract class with a pure virtual function <code>askForPromotion()</code>. The <code>Employee</code> class inherits from <code>AbstractEmployee</code> and provides an implementation for this function. There is another kind of data abstraction in C++ that is related to header files which is not discussed here.</p>"},{"location":"C-CPP/#inheritance","title":"Inheritance","text":"<p>Inheritance is a mechanism where a derived class (child) inherits attributes and behaviors from a base class (parent), promoting code reusability and creating hierarchical relationships. It uses the example of \"Animal\" as a base class and \"Dog\" as a derived class. Inheritance in C++ [Credit: https://www.programiz.com/cpp-programming/inheritance] The following C++ code is provided for creating <code>Developer</code> and <code>Teacher</code> classes that inherit from the <code>Employee</code> class:</p> <p><pre><code>    class Developer:public Employee { // using public eyword to inheritance attributes\n    public:\n        string FavProgrammingLanguage;\n        Developer(string name, string company, int age, string favProgrammingLanguage)\n            :Employee(name,company,age)\n        {\n            FavProgrammingLanguage = favProgrammingLanguage;\n        }\n        void FixBug() {\n            std::cout &lt;&lt; getName() &lt;&lt; \" fixed bug using \" &lt;&lt; FavProgrammingLanguage &lt;&lt; std::endl;\n        }\n    };\n\n    class Teacher: public Employee // using public eyword to inheritance attributes\n    {\n    public:\n        string Subject;\n        Teacher(string name, string company, int age, string subject)\n            :Employee(name, company, age)\n        {\n            Subject = subject;\n        }\n        void PrepareLesson() {\n            std::cout &lt;&lt; Name &lt;&lt; \" is preparing \" &lt;&lt; Subject &lt;&lt; \" lesson\" &lt;&lt; std::endl;\n        }\n    };\n</code></pre> Attention: <code>Name</code> attribute reposed to <code>protected</code> modifier in <code>Employee</code> class. <code>Developer</code> and <code>Teacher</code> inherit from <code>Employee</code> and add specific attributes and methods.</p>"},{"location":"C-CPP/#polymorphism","title":"Polymorphism","text":"<p>Finally, polymorphism is the ability of an object or method to take on many forms. There are twi tyoes of polymorphism as shown in picture bellow. Polymorphism in C++ [Credit: https://www.tpointtech.com/cpp-polymorphism] Here, we are focusing on runtime polymorphism with virtual functions. Let's describes how to create a <code>work()</code> method in the <code>Employee</code> class and override it in the <code>Developer</code> and <code>Teacher</code> classes. The following C++ code  demonstrates how to use base class pointers to call the appropriate <code>work()</code> method for each derived class object, illustrating runtime polymorphism:</p> <pre><code>    #include &lt;iostream&gt;\n    using std::string;\n\n    class AbstractEmployee {\n        virtual void AskForPromotion() = 0;\n    };\n    class Employee:AbstractEmployee {\n    private:\n        string Company;\n        int Age;\n    protected:\n        string Name;\n    public:\n        void setName(string name) { //setter\n            Name = name;\n        }\n        string getName() { //getter\n            return Name;\n        }\n        void setCompany(string company) { //setter\n            Company = company;\n        }\n        string getCompany() {\n            return Company;\n        }\n        void setAge(int age) {\n            if(age&gt;=18)\n                Age = age;\n        }\n        int getAge() {\n            return Age;\n        }\n        void IntroduceYourself() {\n            std::cout &lt;&lt; \"Name: \" &lt;&lt; Name &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Company: \" &lt;&lt; Company &lt;&lt; std::endl;\n            std::cout &lt;&lt; \"Age: \" &lt;&lt; Age &lt;&lt; std::endl;\n        }\n        Employee(string name, string company, int age) {\n            Name = name;\n            Company = company;\n            Age = age;\n        }\n        void AskForPromotion() {\n            if (Age&gt;30)\n                std::cout &lt;&lt; Name &lt;&lt; \" got promoted!\" &lt;&lt; std::endl;\n            else\n                std::cout &lt;&lt; Name &lt;&lt; \", Sorry, No promotion for you!\" &lt;&lt; std::endl;\n        }\n        virtual void Work() { //Mode Virtual\n            std::cout &lt;&lt; Name &lt;&lt; \" is checking email, task backlog, performing tasks ...\"&lt;&lt; std::endl;\n        }\n    };\n    class Developer:public Employee {\n    public:\n        string FavProgrammingLanguage;\n        Developer(string name, string company, int age, string favProgrammingLanguage)\n            :Employee(name,company,age)\n        {\n            FavProgrammingLanguage = favProgrammingLanguage;\n        }\n        void FixBug() {\n            std::cout &lt;&lt; getName() &lt;&lt; \" fixed bug using \" &lt;&lt; FavProgrammingLanguage &lt;&lt; std::endl;\n        }\n        void Work() {  //Overriden Method\n            std::cout &lt;&lt; Name &lt;&lt; \" is writing \" &lt;&lt; FavProgrammingLanguage &lt;&lt; \" code\" &lt;&lt; std::endl;\n        }\n    };\n\n    class Teacher: public Employee \n    {\n    public:\n        string Subject;\n        Teacher(string name, string company, int age, string subject)\n            :Employee(name, company, age)\n        {\n            Subject = subject;\n        }\n        void PrepareLesson() {\n            std::cout &lt;&lt; Name &lt;&lt; \" is preparing \" &lt;&lt; Subject &lt;&lt; \" lesson\" &lt;&lt; std::endl;\n        }\n        void Work() {  //Overriden Method\n            std::cout &lt;&lt; Name &lt;&lt; \" is teaching \" &lt;&lt; Subject &lt;&lt; \" lesson\" &lt;&lt; std::endl;\n        }\n    };\n    int main ()\n    {\n        Developer employee3 = Developer(\"Hamid\", \"Fana\", 24, \"C++\");\n        Teacher employee4 = Teacher(\"Mohammad\", \"Shahrivar School\", 59, \"biology\");\n\n        //Demonstrating Polymorphism\n        Employee* e1 = &amp;employee3;\n        Employee* e2 = &amp;employee4;\n\n        e2-&gt;Work(); // Calls Developer's Work()\n        e1-&gt;Work(); // Calls Teacher's Work()\n        return 0;\n    }\n</code></pre> <p>The <code>Work()</code> method is declared as <code>virtual</code> in the <code>Employee</code> class and overridden in the <code>Developer</code> and <code>Teacher</code> classes. The code then demonstrates how base class pointers (<code>e1</code> and <code>e2</code>) can be used to call the appropriate overridden <code>Work()</code> method for each derived class object, illustrating runtime polymorphism.  </p>"},{"location":"Linux/","title":"Linux","text":"<p>This page will contain Linux and its tools notes.</p>"},{"location":"Linux/#up-and-running","title":"Up and Running","text":""},{"location":"Linux/#install-a-vm","title":"Install a VM","text":"<p>Using VBOX to install a Virtual Machine (VM) and SSHing to it is the first step.</p>"},{"location":"Linux/#create-a-github-repo","title":"Create a Github Repo","text":"<p>Git as a Version Control System (VCS) is an important tool that should be utilized.</p>"},{"location":"Linux/#using-ssh-agent-to-connect-to-github","title":"Using ssh-agent to Connect to GitHub","text":"<p>It's better to use ssh keys. let's do it step-by-step.  </p>"},{"location":"Linux/#1-check-for-an-existing-ssh-key","title":"1. Check for an Existing SSH Key","text":"<p>First, check if you already have an SSH key:</p> <pre><code>ls -al ~/.ssh\n</code></pre> <p>If you see files like <code>id_rsa</code> and <code>id_rsa.pub</code> (or <code>id_ed25519</code> and <code>id_ed25519.pub</code>), you already have an SSH key.</p>"},{"location":"Linux/#2-generate-an-ssh-key-if-needed","title":"2. Generate an SSH Key (if needed)","text":"<p>If you don\u2019t have an SSH key, generate one:</p> <pre><code>ssh-keygen -t ed25519 -C \"your_email@example.com\"\n</code></pre> <p>Follow the prompts and save the key in <code>~/.ssh/id_ed25519</code> (or <code>~/.ssh/id_rsa</code>).</p>"},{"location":"Linux/#3-start-the-ssh-agent-and-add-the-key","title":"3. Start the SSH Agent and Add the Key","text":"<p>Start the <code>ssh-agent</code>:</p> <pre><code>eval \"$(ssh-agent -s)\"\n</code></pre> <p>Add your SSH key to the agent:</p> <pre><code>ssh-add ~/.ssh/id_ed25519\n</code></pre>"},{"location":"Linux/#4-add-the-ssh-key-to-github","title":"4. Add the SSH Key to GitHub","text":"<p>Copy the public key to your clipboard:</p> <pre><code>cat ~/.ssh/id_ed25519.pub\n</code></pre> <p>Go to GitHub SSH Settings, click New SSH Key, and paste the key.</p>"},{"location":"Linux/#5-test-the-connection","title":"5. Test the Connection","text":"<p>Run:</p> <pre><code>ssh -T git@github.com\n</code></pre> <p>If successful, you'll see:</p> <pre><code>Hi username! You've successfully authenticated, but GitHub does not provide shell access.\n</code></pre>"},{"location":"Linux/#6-set-ssh-for-git","title":"6. Set SSH for Git","text":"<p>Ensure Git uses SSH:</p> <pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email \"your_email@example.com\"\ngit remote set-url origin git@github.com:your-username/repository.git\n</code></pre> <p>Now, you can push and pull from GitHub securely using SSH! </p>"},{"location":"Linux/#preparing-vs-code","title":"Preparing VS Code","text":"<p>I think it is better to use <code>vs code</code> instead of <code>vim</code>. <code>vs code</code> is a user friendly, GUI app that make it easier to deal with text files. There are also many extensions to track codes in big projects.</p>"},{"location":"Linux/#working-with-text-files","title":"Working with Text Files","text":"<p>There are many powerful tools in linux that can be used in editing or displaying text files. <code>cat</code>, <code>tr</code>, <code>awk</code>, <code>cut</code>, <code>sort</code> and <code>uniq</code> are the most useful ones.</p>"},{"location":"Linux/#drive-in-linux","title":"Drive in Linux","text":""},{"location":"Linux/#introduction","title":"Introduction","text":"<p>Drives are known as physical disks used to permanently store data into them. The first step towards organizing the storage on a disk is <code>Disk Partitioning</code>. It involves dividing a disk into separate sections, each functioning as an independent disk, which can be managed separately. This segregation helps in managing files, running different operating systems on the same disk, or creating a dedicated space for specific data. There are three types of partitions: 1. Primary Partitions: Directly accessible and used for booting the system. A disk can have up to four primary partitions. 2 Extended Partitions: Created within a primary partition, acting as a container that can hold multiple logical partitions. This is a workaround for the four-partition limit. 3. Logical Partitions: Nested within an extended partition, allowing for more than four partitions on a disk. A partition table tells the operating system how the partitions and data on the drive are organized. Master Boot Record (MBR) and GUID Partition Table (GPT) are two types of partition tables. MBR is a bit of reserved space at the beginning of the drive that contains the information about how the partitions are organized. The MBR also contains code to launch the operating system, and it's sometimes called the Boot Loader. GPT is a newer standard that's slowly replacing MBR. Unlike an MBR partition table, GPT stores the data about how all the partitions are organized and how to boot the OS throughout the drive.  </p> Partiotion Table # of Primary Partitions Max. of Disk Usage MBR Up to 4 Up to 2 TB GPT Up to 128 Up to 1 bilion TB <p>A file system dictates how data is stored and retrieved. Each partition can use a different file system (<code>ext4</code>, <code>NTFS</code>, <code>FAT32</code>, etc.), affecting performance, storage efficiency, and compatibility.  As a general rule, <code>ext4</code> is better suited for handling a large number of small files, while <code>xfs</code> performs better when dealing with a smaller number of large files. Linux offers a plethora of tools for disk partitioning, including: 1. fdisk: A command-line utility ideal for MBR disks. 2. gdisk: Similar to fdisk but for GPT disks. 3. parted: A versatile tool that supports both MBR and GPT disks.</p>"},{"location":"Linux/#logical-volume-management","title":"Logical Volume Management","text":""},{"location":"Linux/#linux-commands","title":"Linux Commands","text":""},{"location":"Linux/#example-scenario","title":"Example Scenario","text":""},{"location":"Linux/#firewall-in-linux-iptables","title":"Firewall in Linux: <code>iptables</code>","text":"<p>The Linux kernel comes with a packet filtering framework named <code>netfilter</code>. It allows you to allow, drop and modify traffic leaving in and out of a system. A tool, <code>iptables</code> builds upon this functionality to provide a powerful firewall, which you can configure by adding rules. In addition, other programs such as <code>fail2ban</code> also use iptables to block attackers. Iptables relies on a set of <code>rules</code> organized into <code>chains</code> that determine the fate of incoming packets. It checks each packet against these rules to decide whether to allow it, drop it, or forward it to another <code>chain</code>. With iptables, you have full control over the network flow, allowing you to filter, block, or shape traffic as needed.  </p>"},{"location":"Linux/#architectural-aspects-of-iptables","title":"Architectural Aspects of <code>iptables</code>","text":"<p><code>iptables</code> rules was designed in a hierarchical architecture. There are 3 units: table, chain and, rule.  Table: The traffic packets are filtered based on tables that are managed by <code>iptables</code>. Most Linux distributions have four tables: <code>filter</code>, <code>mangle</code>, <code>nat</code>, and <code>raw</code>. The default is <code>filter</code>. Chain: Each table contains a set of rulers (or chains) that define what to do with each packet depending on its point (input, output, forward). So each table contains a few chains, such as <code>PREROUTING</code>, <code>INPUT</code>, <code>OUTPUT</code>, <code>FORWARD</code>, and <code>POSTROUTING</code>. The filter table by default contains the <code>INPUT</code>, <code>FORWARD</code>, and <code>OUTPUT</code> chains. Rules:  Each chain can contain rules to match specific packets based on type of traffic (e.g. tcp/udp/icmp), destination or source IP, port, etc. Each rule contains a target which determines what to do with packets that match the rule (e.g. accept or reject). Target: Each rule contains a target which determines what to do with packets that match the rule (e.g. accept or reject). The available targets are <code>ACCEPT</code>, <code>DROP</code>, and <code>REJECT</code>. The difference between <code>DROP</code> and <code>REJECT</code>, is that with <code>REJECT</code>, a connection reset for <code>TCP</code> and a destination host unreachable for <code>UDP/ICMP</code> is sent to the packet source, while <code>DROP</code> dictates that nothing is to be sent to the packet source.</p> <p>For example, a rule in the OUTPUT chain may match to UDP packets that go out to port 53, and the target may say that those packets should be dropped. </p>"},{"location":"Linux/#basic-commands","title":"Basic Commands","text":"<p><code>iptables</code> can be installed by: <pre><code>sudo apt-get install iptables\n</code></pre> Some basic commands are listed bellow: <code>iptables -L</code>: View current rules. <code>iptables -A</code>: Append a new rule to a chain. <code>iptables -D</code>: Delete a rule from a chain. <code>iptables -P</code>: Set default policy for a chain. <code>iptables -F</code>: Flush all rules in a chain.</p>"},{"location":"Linux/#iptables-syntax-and-options","title":"<code>iptables</code> syntax and options:","text":"<p>An iptables command looks as follows: <pre><code>iptables [options] [chain] [criteria] -j [target]\n</code></pre> The table below contains common iptables options:</p> Option Description -A    --append append a rule to a chain. -C  --check Look for a rule that matches a chain. -D  --delete Remove a rule from a chain. -F  --flush Remove all rules. -I  --insert Add a rule to a chain at the provided -L  --list Show all rules in a chain. -N  --new-chain Create a new chain. -V  --verbose Show a more detailed output. -X  --delete-chain Delete a chain."},{"location":"Linux/#examples","title":"Examples","text":"<ul> <li>Allow HTTPS Traffic <pre><code>sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT\n</code></pre></li> <li> <p>Reject SSH Traffic <pre><code>sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT\n</code></pre></p> </li> <li> <p>Reject traffic from an IP address range <pre><code>sudo iptables -A INPUT -m iprange --src-range [IP-address-range] -j REJECT\n# for example\nsudo iptables -A INPUT -m iprange --src-range 192.168.1.100-192.168.1.200 -j REJECT\n</code></pre></p> </li> <li>Enable IP Masquerading for Internet Access</li> </ul> <p><pre><code>sudo iptables -t nat -A POSTROUTING -o &lt;IFNAME&gt; -j MASQUERADE\n</code></pre> The provided command is used to enable IP Masquerading, which is a form of network address translation (NAT) that allows devices on a private network to communicate with the internet using the public IP address of the gateway. This is commonly used in scenarios where you have a private network (e.g., a home or office network) and want to allow devices on that network to access the internet.</p> <ul> <li>Delete a specific rule <pre><code># list all rules:\nsudo iptables -L --line-numbers\n#Locate the line number of the firewall rule you want to delete:\n#Replace [number] with the rule line number you want to remove in the command bellow\nsudo iptables -D INPUT [number]\n</code></pre></li> </ul>"},{"location":"Linux/#save-the-rules","title":"Save The Rules","text":"<p><code>iptables</code> doesn't save the rules - These are available aslong as the machine is up. To keep <code>iptables</code> firewall rules after reboot, install the persistent package: <pre><code>sudo apt install iptables-persistent\n</code></pre> Enable the service <pre><code>sudo systemctl enable iptables\n</code></pre> Save them <pre><code>sudo netfilter-persistent save\n</code></pre></p>"},{"location":"Linux/#references-and-further-readings","title":"References and Further Readings","text":"<p>1 - iptables Tutorial: A Beginner's Guide to the Linux Firewall 2 - What Is iptables and How to Use It? 3 - An In-Depth Guide to iptables, the Linux Firewall 4 - Linux for Network Engineers: iptables 5 - Secure Your Network with iptables</p>"},{"location":"RAN/","title":"Radio Access Network","text":"<p>This page will contain concepts in Radio Access Network (RAN).</p>"},{"location":"RAN/#basic-and-concepts","title":"Basic and Concepts","text":"<p>This section is the most topic that related to telecommunications.</p>"},{"location":"RAN/#scheduling","title":"Scheduling","text":"<p>To investigate scheduling, it is better to start with multiplexing and multiple access. In communication systems, multiplexing and multiple access are two fundamental concepts that help manage and optimize resource allocation. Though they seem similar, they serve different purposes. Let's start with multiplexing</p>"},{"location":"RAN/#multiplexing","title":"Multiplexing","text":"<p>Multiplexing is used when multiple signals need to be transmitted over a shared medium efficiently. The key idea is pre-planned resource allocation, meaning that bandwidth or time is divided among signals in a fixed way. So, in multiplexing it is easy to coordinate the senders. Multiplexing is used in a point-to-point situation for example in backhaul, when different data sources come into one backhaul link and then go to its destiny:). There are 4 types of Multiplexing: - TDM (Time Division Multiplexing): Each signal gets a fixed time slot, even if it has nothing to send. - FDM (Frequency Division Multiplexing): Each signal is assigned a fixed frequency band. - CDM (Code Division Multiplexing): Each signal gets a unique code to separate it from others. - SDM (Space Division Multiplexing): Signals are separated based on different spatial paths (e.g., MIMO in wireless systems). To have a better understanding of multiplexing, Applications of Multiplexing table are prepared.  </p> Application Multiplexing Type Example Optical Networks (WDM) Wavelength Division Multiplexing (FDM) Multiple light wavelengths transmitted in a fiber. Telephony (T1/E1 lines) TDM Multiple voice calls transmitted over a single line. FM Radio FDM Multiple stations operate at different frequency bands."},{"location":"RAN/#multiple-access","title":"Multiple Access","text":"<p>Multiple access allows multiple users (UEs, devices) to share the available radio spectrum dynamically. Unlike multiplexing, resources are not permanently assigned but are allocated as needed. so despite of multiplexing ,which is about combining multiple signals into one channel before transmission and in a single point-to-point link, Multiple Access is about managing how multiple users share the spectrum during transmission. Types of Multiple Access are listed below.  </p> <ul> <li>FDMA (Frequency Division Multiple Access): Each user gets a fixed frequency band.  </li> <li>TDMA (Time Division Multiple Access): Each user gets a time slot dynamically.  </li> <li>CDMA (Code Division Multiple Access): Users share the same frequency but have unique codes.  </li> <li>OFDMA (Orthogonal Frequency Division Multiple Access): Subcarriers are dynamically shared among users (used in LTE, 5G).  </li> </ul> <p>Applications of Multiple Access are collected in the following table.  </p> Application Multiple Access Type Example Mobile Networks (GSM, LTE, 5G) FDMA, TDMA, OFDMA, NOMA UEs share frequency dynamically based on demand. Wi-Fi (CSMA/CA) Contention-based Access Devices compete for access to the shared spectrum.  It is less coordinated than others. Satellite Communication CDMA, TDMA Multiple ground stations communicate with the satellite."},{"location":"RAN/#scheduling_1","title":"Scheduling","text":"<p>Multiple Access (MA) methods are used in RAN, as you know. But how to manage and coordinate users? Based on what? Who has the right to access the resources right now? These questions are answered by MAC layer but MA is done in PHY (because of spectrum, of course). MAC scheduling is a critical function in mobile networks that dynamically allocates radio resources (e.g., Physical Resource Blocks - PRBs) to UEs based on various parameters such as QoS requirements, channel conditions, and traffic demand. The goal of scheduling is to maximize network efficiency while ensuring fairness and QoS compliance.  </p>"},{"location":"RAN/#scheduling-basics-in-4g","title":"Scheduling Basics, in 4G","text":"<p>The use of OFDMA naturally leads to conceptualizing the radio spectrum as a 2-D resource, as shown below, with the subcarriers represented in the vertical dimension and the time to transmit symbols on each subcarrier represented in the horizontal dimension. The basic unit of transmission, called a Resource Element (RE), corresponds to a 15-kHz band around one subcarrier frequency and the time it takes to transmit one OFDMA symbol. The number of bits that can be encoded in each symbol depends on the modulation scheme in use. For example, using Quadrature Amplitude Modulation (QAM), 16-QAM yields 4 bits per symbol and 64-QAM yields 6 bits per symbol. The details of the modulation need not concern us here; the key point is that there is a degree of freedom to choose the modulation scheme based on the measured channel quality, sending more bits per symbol (and thus more bits per second) when the quality is high.</p> <p></p> <p>A scheduler allocates some number of REs to each user that has data to transmit during each 1 ms Transmission Time Interval (TTI), where users are depicted by different colored blocks in Figure above. The only constraint on the scheduler is that it must make its allocation decisions on blocks of 7x12=84 resource elements, called a Physical Resource Block (PRB). Figure shows shows two back-to-back PRBs. Of course time continues to flow along one axis, and depending on the size of the available frequency band (e.g., it might be 100 MHz wide), there may be many more subcarrier slots (and hence PRBs) available along the other axis, so the scheduler is essentially preparing and transmitting a sequence of PRBs.  </p> <p>Note that OFDMA is not a coding/modulation algorithm, but instead provides a framework for selecting a specific coding and modulation for each subcarrier frequency. QAM is one common example modulation. It is the scheduler\u2019s responsibility to select the modulation to use for each PRB, based on the CQI feedback it has received. The scheduler also selects the coding on a per-PRB basis, for example, by how it sets the parameters to the turbo code algorithm.</p> <p>The 1-ms TTI corresponds to the time frame in which the scheduler receives feedback from users about the quality of the signal they are experiencing. This is the role of CQI: once every millisecond, each user sends a set of metrics, which the scheduler uses to make its decision as to how to allocate PRBs during the subsequent TTI.</p> <p>Another input to the scheduling decision is the QoS Class Identifier (QCI), which indicates the quality-of-service each class of traffic is to receive. In 4G, the QCI value assigned to each class (there are twenty six such classes, in total) indicates whether the traffic has a Guaranteed Bit Rate (GBR) or not (non-GBR), plus the class\u2019s relative priority within those two categories. (Note that the 5QI parameter serves the same purpose as the QCI parameter in 4G.)</p> <p>Finally, keep in mind that Figure above focuses on scheduling transmissions from a single antenna, but the MIMO technology described above means the scheduler also has to determine which antenna (or more generally, what subset of antennas) will most effectively reach each receiver. But again, in the abstract, the scheduler is charged with allocating a sequence of Resource Elements.</p> <p>Note that the scheduler has many degrees of freedom: it has to decide which set of users to service during a given time interval, how many resource elements to allocate to each such user, how to select the coding and modulation levels, and which antenna to transmit their data on. This is an optimization problem that, fortunately, we are not trying to solve here.</p>"},{"location":"RAN/#scheduling-in-5g","title":"Scheduling in 5G","text":"<p>Fundamentally, 5G defines a family of waveforms \u2014unlike LTE, which specified only one waveform\u2014 each optimized for a different band in the radio spectrum. - The bands with carrier frequencies below 1 GHz are designed to deliver mobile broadband and massive IoT services with a primary focus on range. - Carrier frequencies between 1-6 GHz are designed to offer wider bandwidths, focusing on mobile broadband and mission-critical applications. - Carrier frequencies above 24 GHz (mmWaves) are designed to provide super-wide bandwidths over short, line-of-sight coverage. </p> <p>These different waveforms affect the scheduling and subcarrier intervals (i.e., the <code>size</code> of the resource elements ). - For frequency range 1 (410 MHz - 7125 MHz), 5G allows maximum 100 MHz bandwidths. In this case, there are three waveforms with subcarrier spacings (SCS) of 15, 30 and 60 kHz. (We used 15 kHz in the example shown in Figure above.) The corresponding to scheduling intervals of 0.5, 0.25, and 0.125 ms, respectively. (We used 0.5 ms in the example shown in figure above). - For millimeter bands, also known as frequency range 2 (24.25 GHz - 52.6 GHz), bandwidths may go from 50 MHz up to 400 MHz. There are two waveforms, with subcarrier spacings of 60 kHz and 120 kHz. Both have scheduling intervals of 0.125 ms. These various configurations of subcarrier spacing and scheduling intervals are sometimes called the numerology of the radio\u2019s air interface.  </p> <p>This range of numerology is important because it adds another degree of freedom to the scheduler. In addition to allocating radio resources to users, it has the ability to dynamically adjust the size of the resource by changing the waveform being used. With this additional freedom, fixed-sized REs are no longer the primary unit of resource allocation. We instead use more abstract terminology, and talk about allocating Resource Blocks to subscribers, where the 5G scheduler determines both the size and number of Resource Blocks allocated during each time interval. Figure below depicts the role of the scheduler from this more abstract perspective. Just as with 4G, CQI feedback from the receivers and the 5QI quality-of-service class selected by the subscriber are the two key pieces of input to the scheduler. Note that the set of 5QI values available in 5G is considerably greater than its QCI counterpart in 4G, reflecting the increasing differentiation among classes that 5G aims to support. For 5G, each class includes the following attributes:</p> <ul> <li>Resource Type: Guaranteed Bit Rate (GBR), Delay-Critical GBR, Non-GBR  </li> <li>Priority Level </li> <li>Packet Delay Budget </li> <li>Packet Error Rate </li> <li>Maximum Data Burst </li> <li>Averaging Window </li> </ul> <p>Note that while the preceding discussion could be interpreted to imply a one-to-one relationship between subscribers and a 5QI, it is more accurate to say that each 5QI is associated with a class of traffic (often corresponding to some type of application), where a given subscriber might be sending and receiving traffic that belongs to multiple classes at any given time. </p>"},{"location":"RAN/#types-of-scheduling","title":"Types of Scheduling","text":"<p>So we know that mobile radio communication experiences rapid and unpredictable channel variations due to frequency-selective fading, path loss, and interference. To optimize resource utilization, techniques like channel-dependent scheduling, link adaptation, and hybrid ARQ are used. - Channel-dependent scheduling allocates radio resources dynamically to maximize efficiency, ensuring minimum resource usage per user while meeting QoS requirements. - Link adaptation adjusts transmission parameters (e.g., power, modulation, and coding) based on channel conditions to maintain efficient data transfer. - Hybrid ARQ provides error correction by requesting retransmissions of corrupted data, complementing scheduling and link adaptation.  </p>"},{"location":"RAN/#link-adaptation-power-vs-rate-control","title":"Link Adaptation: Power vs. Rate Control","text":"<ul> <li>Power Control (used in CDMA) adjusts transmit power to maintain a constant signal-to-noise ratio (SNR), ensuring stable transmission.  </li> <li>Rate Control (adaptive modulation and coding, AMC) adjusts data rates instead of power, making better use of transmission power. Higher modulation schemes (e.g., 16QAM, 64QAM) are used in good conditions, while lower ones (e.g., QPSK) are used in poor conditions. The data rate should be high as possible.  </li> </ul>"},{"location":"RAN/#channel-dependent-scheduling","title":"Channel-Dependent Scheduling","text":"<p>Scheduling determines how shared radio resources are allocated among users. In downlink scheduling, transmissions can be orthogonal in time (TDM), frequency (FDM), or code (CDM). There are 3 approach: - Max-C/I Scheduling prioritizes users with the best channel conditions, maximizing system capacity but potentially starving users with poor conditions. - Round-Robin Scheduling assigns equal time to all users, ensuring fairness but reducing efficiency. - Proportional-Fair Scheduling balances throughput and fairness by scheduling users based on both instantaneous and average channel conditions. A practical scheduler must exploit fast channel variations for efficiency while maintaining fairness across users, often using a combination of TDM, FDM, and CDM.</p> <p>The first picture shows the Max-C/I Scheduling and the second one shows all three methods. </p>"},{"location":"RAN/#references-and-further-readings","title":"References and Further Readings","text":"<p>1 - Private 5G: a System Approach, Chapter 3: Radio Transmission 2 - The Difference Between Multiplexing and Multiple Access 3 - OAI's mac-usage.md 4 - 4G: LTE/LTE-Advanced for Mobile Broadband</p>"},{"location":"RAN/#architecture","title":"Architecture","text":"<p>RAN Architecture and its evolution!  </p>"},{"location":"RAN/#protocol-stack","title":"Protocol Stack","text":"<p>How 5G stuff works?</p>"},{"location":"Virtualization/","title":"Virtualization","text":"<p>This page will contain information about virtualization in computing systems.</p> <ul> <li>Virtualization</li> <li>Definitions<ul> <li>Types of Virtualization</li> <li>Hypervisors</li> <li>Containers vs Virtual Machines</li> <li>Scaling in Virtualized Environments</li> <li>Virtualization Tools and Ecosystem</li> <li>References and Further Readings</li> </ul> </li> <li>Virtual Machines<ul> <li>Install Proxmox</li> <li>Download files</li> <li>Create a bootable USB with Rufus (on Windows)</li> <li>BIOS/UEFI setup on the old PC</li> <li>Install Proxmox VE</li> <li>First login (Web UI)</li> <li>Post-install housekeeping (no subscription repo)</li> <li>Storage layout (use multiple disks)</li> <li>Upload a Linux ISO and create the first VM (Ubuntu example)<ul> <li>Upload ISO</li> <li>Create VM</li> <li>Scale Up The Storage</li> </ul> </li> </ul> </li> </ul>"},{"location":"Virtualization/#definitions","title":"Definitions","text":"<p>Virtualization is the process of creating an abstract layer between hardware resources and the software that uses them. Instead of applications directly accessing physical hardware, a virtualization layer (hypervisor or container runtime) allows multiple isolated environments to share the same physical system efficiently. Using it lets us fully utilize hardware capabilities and makes disaster recovery easier. However, it introduces some security risks and software licensing costs.  </p>"},{"location":"Virtualization/#types-of-virtualization","title":"Types of Virtualization","text":"<ul> <li> <p>Hardware Virtualization: Full virtual machines (VMs) with dedicated virtual CPUs, memory, disks, and NICs.</p> </li> <li> <p>Operating System Virtualization: Containers running on a shared kernel while remaining isolated from each other (e.g., Docker, Podman, LXC).</p> </li> <li> <p>Storage Virtualization: Abstracting storage resources into pools for flexible provisioning.</p> </li> <li> <p>Network Virtualization: Overlay networks and SDN (Software-Defined Networking) to decouple network services from hardware.</p> </li> </ul>"},{"location":"Virtualization/#hypervisors","title":"Hypervisors","text":"<ul> <li> <p>Type 1 (Bare-metal): Run directly on the hardware (e.g., <code>VMware ESXi</code>, <code>Proxmox VE</code>, <code>Xen</code>, <code>Hyper-V</code>).</p> </li> <li> <p>Type 2 (Hosted): Run on top of a host operating system (e.g., <code>VirtualBox</code>, <code>VMware Workstation</code>).</p> </li> </ul>"},{"location":"Virtualization/#containers-vs-virtual-machines","title":"Containers vs Virtual Machines","text":"<ul> <li> <p>VMs: Each VM runs its own guest OS, providing full isolation and flexibility but with higher overhead.</p> </li> <li> <p>Containers: Share the host OS kernel, lightweight and faster, ideal for microservices and DevOps workflows.</p> </li> </ul> <p> Virtualization types: Container-based and VM-based -- Reference: aquasec.com</p>"},{"location":"Virtualization/#scaling-in-virtualized-environments","title":"Scaling in Virtualized Environments","text":"<ul> <li> <p>Scale Up (Vertical Scaling): Adding more resources (CPU, RAM, storage) to a single VM or container. Example: resizing a VM disk using <code>fdisk</code>, <code>vgextend</code>, <code>lvextend</code>, and <code>resizefs</code>.</p> </li> <li> <p>Scale Out (Horizontal Scaling): Adding more VMs or containers to distribute workload across multiple nodes. Common in <code>Kubernetes</code> or cloud-native architectures.</p> </li> </ul>"},{"location":"Virtualization/#virtualization-tools-and-ecosystem","title":"Virtualization Tools and Ecosystem","text":"<p>Hypervisors: <code>Proxmox VE</code>, <code>VMware ESXi</code>, <code>KVM</code>, <code>Xen</code>.</p> <p>Container Runtimes: <code>Docker</code>, <code>Podman</code>, <code>containerd</code>.</p> <p>DevOps &amp; Orchestration: <code>Terraform</code> (infrastructure as code), <code>Ansible</code> (automation), <code>Kubernetes</code> (orchestration), <code>GitLab CI</code>, <code>Nexus</code> (artifact repository).</p>"},{"location":"Virtualization/#references-and-further-readings","title":"References and Further Readings","text":"<ol> <li>Virtualization in Cloud Computing and Types </li> <li>Virtualization - TechTarget </li> <li>Containerization vs. Virtualization: Key Differences and Use Cases</li> </ol>"},{"location":"Virtualization/#virtual-machines","title":"Virtual Machines","text":"<p>Virtualization on a host OS is old hat and not very exciting anymore. My first stop was VMware ESXi, but hardware limitations made it frustrating. That\u2019s when I shifted to Proxmox VE, and it clicked immediately. Open-source, lightweight, community-driven \u2014 and it just worked with my old hardware. So let's begin with installing Proxmox.</p>"},{"location":"Virtualization/#install-proxmox","title":"Install Proxmox","text":""},{"location":"Virtualization/#download-files","title":"Download files","text":"<p>Proxmox VE ISO: from the official Proxmox site (Downloads \u2192 ISO Images). Rufus (to make a USB installer): download from rufus.ie (portable EXE, no install needed).  </p>"},{"location":"Virtualization/#create-a-bootable-usb-with-rufus-on-windows","title":"Create a bootable USB with Rufus (on Windows)","text":"<p>Insert an 8 GB+ USB stick (it will be erased). Open Rufus \u2192 Device: your USB. Boot selection: pick the Proxmox ISO you downloaded. Partition scheme: - MBR if the target PC boots in Legacy BIOS. - GPT if the PC boots in UEFI. Leave File system = FAT32, Cluster size = default. Click Start \u2192 OK to write in ISO mode.  </p>"},{"location":"Virtualization/#biosuefi-setup-on-the-old-pc","title":"BIOS/UEFI setup on the old PC","text":"<p>Consider these points: - Enable Intel VT-x/AMD-V (virtualization). - (If present) enable VT-d/IOMMU. - Disable Secure Boot (older hardware may not have this). - Set USB as the first boot device (or use the one-time boot menu key).  </p>"},{"location":"Virtualization/#install-proxmox-ve","title":"Install Proxmox VE","text":"<p>First considerations: - Boot from the USB \u2192 choose Install Proxmox VE (Graphical). - License: accept. - Target disk: pick your SSD (fastest). - File system: choose LVM/ext4 (recommended for 16 GB RAM). Avoid ZFS on low RAM. - Country/Time/Keyboard: set yours. - Password &amp; Email: set root password (this is for Proxmox login).  </p> <p>Management network: - Pick your NIC (e.g., enp3s0/eth0). - Set a Static IP if possible (recommended), e.g.   - IP: 192.168.1.100   - Netmask: 255.255.255.0   - Gateway: 192.168.1.1 (your router)   - DNS: your router or 1.1.1.1  </p> <p>Install \u2192 Reboot \u2192 remove USB.  </p>"},{"location":"Virtualization/#first-login-web-ui","title":"First login (Web UI)","text":"<p>On another machine on the same LAN, open: <code>https://&lt;your-proxmox-node-ip&gt;:8006</code> (e.g., <code>https://192.168.1.100:8006</code>) Ignore the certificate warning (self-signed). Login: root + the password you set.  </p> <p> Proxmox First Login on the Web UI </p>"},{"location":"Virtualization/#post-install-housekeeping-no-subscription-repo","title":"Post-install housekeeping (no subscription repo)","text":"<p>By default, Proxmox points to the enterprise repo (requires a subscription). Switch to the free repo: Open Shell in the Web UI (top-right) or SSH to the node, then:  - Disable the enterprise repo:  </p> <p>Go to Web UI, from the left panel, choose node (here <code>pve</code>) -&gt; Updates -&gt; Repositories. Select <code>pve-enterprise-sources</code> and <code>ceph-sources</code>, and disable them.  - Enable the no-subscription repo (Proxmox VE 8.x on Debian 13 <code>trixie</code>):  </p> <p>Open a shell, <code>editor /etc/apt/sources.lists.d/pve-no-subscription</code> and paste following content: <pre><code>deb http://download.proxmox.com/debian/pve trixie pve-no-subscription\n</code></pre> Now, You can update and upgrade the OS: <pre><code>apt update\napt full-upgrade -y\nreboot\n</code></pre></p> <p>After reboot, you\u2019re on the latest Proxmox VE 8 (free/no-subscription).  </p>"},{"location":"Virtualization/#storage-layout-use-multiple-disks","title":"Storage layout (use multiple disks)","text":"<p>local-lvm (thin): default place for VM disks (lives on the SSD\u2014fast).  </p> <p>local: for ISO images &amp; backups (also on SSD by default).  </p> <p>To add any other drive for VM disks/ISO/backups:  </p> <p><code>Datacenter \u2192 &lt;node&gt; \u2192 Disks \u2192 Directory \u2192 Create</code> </p> <p>Point it to your drive (e.g., <code>/mnt/hdd1</code>), format <code>ext4</code>, give it an ID (e.g., <code>hdd-dir</code>).  </p> <p>Then go to <code>Datacenter \u2192 Storage \u2192 Add \u2192 Directory</code>, pick that path and enable <code>Disk image and/or ISO image</code> as you like.  </p>"},{"location":"Virtualization/#upload-a-linux-iso-and-create-the-first-vm-ubuntu-example","title":"Upload a Linux ISO and create the first VM (Ubuntu example)","text":""},{"location":"Virtualization/#upload-iso","title":"Upload ISO","text":"<p><code>Datacenter \u2192 &lt;node&gt; \u2192 local (Storage) \u2192 ISO Images \u2192 Upload \u2192 pick ubuntu-XX.YY-server.iso.</code> </p>"},{"location":"Virtualization/#create-vm","title":"Create VM","text":"<p>Create VM (top-right).  </p> <ul> <li>General: Name it (e.g., ubuntu01).  </li> <li>OS: Select the uploaded ISO.  </li> <li>System: Keep defaults (BIOS SeaBIOS is fine for old PCs).  </li> <li>Hard Disk: SCSI, on local-lvm, size e.g., 40 GB.  </li> <li>CPU: Host type, 2 cores.  </li> <li>Memory: 4096 MB (4 GB).  </li> <li>Network: Bridge vmbr0; Model VirtIO (paravirtualized).  </li> </ul> <p>Before first boot: <code>VM \u2192 Options \u2192 QEMU Guest Agent \u2192 Enable = Yes.</code> Start the VM: <code>Console \u2192 install Ubuntu</code> (tick <code>OpenSSH server</code> during install).  </p> <p>Inside the VM after first boot: <pre><code>sudo apt update\nsudo apt install -y qemu-guest-agent\nsudo systemctl enable --now qemu-guest-agent\n</code></pre></p> <p>Now you can SSH in from your LAN: <pre><code>ssh &lt;username&gt;@&lt;vm-ip&gt;\n</code></pre></p> <p>(Find the VM\u2019s IP in Proxmox summary once the guest agent isactive on the VM config and is running (<code>apt-get install qemu-guest-agent</code>) in the VM OS, or simply via <code>ip a</code> in the VM shell.) First VM Stats in Proxmox </p>"},{"location":"Virtualization/#scale-up-the-storage","title":"Scale Up The Storage","text":"<p>First of all, add a new disk from VM hardware panel. After that you can see this on the <code>lsblk</code> command output. if its name is <code>/dev/sdb</code>, use <code>fdisk /dev/sdb</code> command to format this. you have to press <code>n</code> to create new filesystem, <code>p</code> for primary, and some <code>enter</code> keys to confirm default values. after that, you can use <code>t</code> to change type of it to <code>8e</code> i.e.  <code>linux-lvm</code>.  </p> <p>You can think of LVM as \"dynamic partitions\": it lets you create, resize, and delete logical volumes from the command line while Linux is running, so the kernel immediately recognizes the changes without a reboot. LVM lets you merge physical volumes into volume groups and then create, resize, or delete logical volumes as flexible partitions. So the structure is made up with 3 entity: - Physical Volumes (PV): physical block devices (or device-mapper devices) with an LVM header - the raw building blocks. - Volume Groups (VG): pools that combine physical volumes into a single logical storage pool. - Logical Volumes (LV): flexible \u201cpartitions\u201d carved from a volume group that users and applications use.  </p> <p>to read new partitions use <code>sudo partprobe</code>, then you can create a PV by prompting <code>sudo pvcreate /dev/sdb1</code>. To extend <code>ubuntu-vg</code> Volume Group and <code>lv-0</code> Logical Volume: <pre><code>sudo vgextend ubuntu-vg /dev/sdb1\nlvextend -l +100%FREE  /dev/ubuntu-vg/lv-0\n</code></pre> Then you can resizes the filesystem on the logical volume to match the LV\u2019s new size and check it. <pre><code>resize2fs /dev/ubuntu-vg/lv-0\ndf -h\n</code></pre> You\u2019re all set - once the filesystem resize completes and you verify the new size with <code>df -h</code>, the extra space from the added disk is available to the system and applications immediately. This lets you grow storage on the fly without downtime, and you can repeat the same <code>PV \u2192 VG \u2192 LV</code> steps later if you add more disks or need to reallocate space.  </p>"}]}